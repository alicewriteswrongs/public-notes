<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ðŸ’… Decorators, TypeScript, and Stencil</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
  .note {
    border: 1px dashed lightgray;
    padding: 0.5em 1em;
    padding-top: 0.25em;
    padding-bottom: 0.25em;
  }

  .note::before {
      content: "Note:";
      font-style: italic;
      font-size: 14px;
      border-bottom: 1px solid lightgray;
  }

  .note p {
    font-size: 16px;
    margin: 0.5em 0;
  }

  .note p:first-child {
    margin-top: 0.25em;
  }

  p {
    text-align: justify;
  }

  #TOC::before {
    content: "Contents";
    font-size: 1.5em;
    font-weight: bold;
  }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">ðŸ’… Decorators, TypeScript, and Stencil</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#terms" id="toc-terms">Terms</a></li>
</ul></li>
<li><a href="#what-is-covered-by-the-tc39-decorator-proposal"
id="toc-what-is-covered-by-the-tc39-decorator-proposal">What is covered
by the TC39 decorator proposal?</a></li>
<li><a href="#typescripts-decorator-support"
id="toc-typescripts-decorator-support">TypeScriptâ€™s decorator
support</a>
<ul>
<li><a href="#ts-decorators" id="toc-ts-decorators">TS Decorators</a>
<ul>
<li><a href="#example" id="toc-example">Example</a></li>
<li><a href="#differences-with-es-decorators"
id="toc-differences-with-es-decorators">Differences with ES
Decorators</a></li>
</ul></li>
<li><a href="#es-decorators-in-typescript-5.0"
id="toc-es-decorators-in-typescript-5.0">ES Decorators in TypeScript
5.0</a></li>
</ul></li>
<li><a
href="#how-are-stencils-built-in-decorators-prop-watch-etc-implemented"
id="toc-how-are-stencils-built-in-decorators-prop-watch-etc-implemented">How
are Stencilâ€™s built-in decorators (<code>Prop</code>,
<code>Watch</code>, etc) implemented?</a></li>
<li><a href="#stencils-support-for-custom-decorators"
id="toc-stencils-support-for-custom-decorators">Stencilâ€™s support for
custom decorators</a>
<ul>
<li><a href="#in-versions-2.18.1" id="toc-in-versions-2.18.1">In
versions &lt;=2.18.1</a></li>
<li><a href="#in-versions-2.19.0" id="toc-in-versions-2.19.0">In
versions 2.19.0+</a></li>
</ul></li>
<li><a href="#recommendations-for-decorator-support-in-stencil"
id="toc-recommendations-for-decorator-support-in-stencil">Recommendations
for decorator support in Stencil</a>
<ul>
<li><a href="#possible-scenarios" id="toc-possible-scenarios">Possible
scenarios</a>
<ul>
<li><a href="#status-quo" id="toc-status-quo">Status quo</a></li>
<li><a
href="#custom-ts-decorators-or-es-decorators-alongside-stencil-decorators"
id="toc-custom-ts-decorators-or-es-decorators-alongside-stencil-decorators">Custom
TS Decorators <em>or</em> ES Decorators alongside Stencil
decorators</a></li>
<li><a
href="#support-custom-ts-decorators-and-custom-es-decorators-maintain-stencil-decorators"
id="toc-support-custom-ts-decorators-and-custom-es-decorators-maintain-stencil-decorators">Support
custom TS Decorators <em>and</em> custom ES Decorators, maintain Stencil
decorators</a></li>
<li><a href="#all-in-on-es-decorators"
id="toc-all-in-on-es-decorators">All in on ES Decorators</a></li>
</ul></li>
<li><a href="#my-recommendation" id="toc-my-recommendation">My
recommendation</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>The TypeScript team has <a
href="https://github.com/microsoft/TypeScript/pull/50820">recently
merged a PR</a> implementing <a
href="https://github.com/tc39/proposal-decorators">the stage 3 TC39
proposal for implementing decorators in ECMAScript</a>. This development
has some consequences for how we handle decorators in Stencil, where
they have long been used as the syntactic lever for a lot of the basic
functionality that we provide to component authors. With that in mind, I
wrote this document to summarize the state of the decorator world and
facilitate getting us on the same page about where we are and where we
should go.</p>
<h2 id="terms">Terms</h2>
<p>A few definitions that Iâ€™m using throughout this document to
distinguish between a few closely related things.</p>
<ul>
<li><em>ES Decorators</em>: this refers narrowly to decorators as
specified in the <a
href="https://github.com/tc39/proposal-decorators/">TC39 decorator
proposal</a> <em>as it is currently written</em>.</li>
<li><em>TS Decorators</em>: this refers to decorators as they have been
available in TypeScript for a while when the
<code>experimentalDecorators</code> flag is set.</li>
<li><em>Stencil Decorators</em>: this refers to the built-in decorators
in Stencil that form part of our component authoring DSL
(<code>@Watch</code>, <code>@Prop</code>, <code>@State</code> and
friends).</li>
</ul>
<h1 id="what-is-covered-by-the-tc39-decorator-proposal">What is covered
by the TC39 decorator proposal?</h1>
<p>The <a href="https://github.com/tc39/proposal-decorators/">TC39
decorator proposal</a> was <a
href="https://github.com/tc39/proposal-decorators/commit/77cb016cac4653b15f93a908b00b041315e4b6e5">advanced
to stage 3</a> in April 2022, indicating that it is very likely to be
accepted as part of the ECMAScript standard in something very close to
its present form. It standardizes a notion of decorators in ECMAScript
as functions which correspond to the following interface:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Decorator <span class="op">=</span> (value<span class="op">:</span> Input<span class="op">,</span> context<span class="op">:</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  kind<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  name<span class="op">:</span> <span class="dt">string</span> <span class="op">|</span> <span class="dt">symbol</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  access<span class="op">:</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">get</span><span class="op">?</span>()<span class="op">:</span> <span class="dt">unknown</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span><span class="op">?</span>(value<span class="op">:</span> <span class="dt">unknown</span>)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  private<span class="op">?:</span> <span class="dt">boolean</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  static<span class="op">?:</span> <span class="dt">boolean</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  addInitializer<span class="op">?</span>(initializer<span class="op">:</span> () <span class="kw">=&gt;</span> <span class="dt">void</span>)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}) <span class="kw">=&gt;</span> Output <span class="op">|</span> <span class="dt">void</span><span class="op">;</span></span></code></pre></div>
<p>Using the <code>@decoratorname</code> syntax, functions corresponding
to this interface can be applied to classes, class fields, class
methods, and class accessors. That could look, for example, something
like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Example {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  @reactive accessor myBool <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Multiple decorators can be applied to the same thing, and they are
evaluated left to right, top to bottom. A decorator can do essentially
three things:</p>
<ul>
<li><strong>replace</strong> a value with another value which â€˜has the
same semanticsâ€™<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></li>
<li>provide <strong>access</strong> to the value for some other purpose
(for instance, grabbing the value of a property on a class to trigger a
side effect with it, but not modifying the property itself)</li>
<li><strong>initialize</strong> a value by running a little bit of
code.</li>
</ul>
<p>If we consider the example of attaching a decorator to a class field
(as Stencil component authors are used to doing), decorators could be
used to update the value on the class at runtime, to trigger some side
effect with the value, set up a subscription, etc. They are quite
flexible and provide a first-class way to re-use small bits of
functionality.</p>
<p>The standardization hews quite close to an informal and loose
â€˜standardâ€™ that has emerged for decorators in the JS world, defined in
practice by the implementations of series of different tools like
transpilers and so on (these were in part based on earlier versions of
the TC39 proposal). Stencil itself implements a dialect of this loose
standard, having used its own implementation of decorators for several
years. However, there are some important differences between ES
Decorators, Stencil Decorators, and TS Decorators which have
implications for Stencil as a tool.</p>
<p>The <a href="https://github.com/tc39/proposal-decorators/">full TC39
proposal</a> contains a lot of detailed information and I wonâ€™t attempt
to summarize all of it here. Itâ€™s not a bad idea to give it a read
through I think!</p>
<h1 id="typescripts-decorator-support">TypeScriptâ€™s decorator
support</h1>
<p>Here I want to just briefly review the state of TypeScript support,
before and after <a
href="https://github.com/microsoft/TypeScript/pull/50820">the recent
PR</a> which implemented support for ES Decorators. I would suggest
reading through the PR description as well.</p>
<h2 id="ts-decorators">TS Decorators</h2>
<p>In current stable releases of TypeScript, support for decorators can
be enabled by setting the <code>--experimentalDecorators</code>
configuration flag. With this option turned on you can use decorators
mostly along the lines of whatâ€™s explained in the TC39 proposal, with a
few important differences.</p>
<div class="note">
<p>Recall that decorators as enabled by this option in TypeScript are
referred to as <em>TS Decorators</em>.</p>
</div>
<h3 id="example">Example</h3>
<p>Hereâ€™s a quick example which decorates a class field and just logs
its arguments (<a
href="https://www.typescriptlang.org/play?useDefineForClassFields=true&amp;target=99&amp;module=7#code/MYewdgzgLgBAsgTwCIFNQCcCGUToFwwAUAlDALwB8MACuiAA4rpTJq7a7lGmUwDeAKBgx0KKAFd0YIlEzoA5mIIB5AEYArNFAA0MenUbMEAaRQIC0dAEsw8mAB8YEBAFtVIADY8qg4cNCQnigAdB4g8oR8MLIKYrr6DEwspggwAL7EANxC6dlp2QLAHpgQEPAIAMIgLvTgKGCwvjAAAoioGBzoJDkAJmxYUCg9tAwWUNa2XABEAGYgIKpyU3lAA">TS
playground</a>):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> MyDecorator<span class="op">:</span> () <span class="kw">=&gt;</span> PropertyDecorator <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (target<span class="op">:</span> <span class="bu">Object</span><span class="op">,</span> propertyKey<span class="op">:</span> <span class="dt">string</span> <span class="op">|</span> <span class="dt">symbol</span>) <span class="kw">=&gt;</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>({ target<span class="op">,</span> propertyKey })<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyComponent {</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  @<span class="fu">MyDecorator</span>()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  decoratedProp<span class="op">:</span> <span class="dt">string</span> <span class="op">=</span> <span class="st">&quot;foobar&quot;</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>If you run this youâ€™ll see
<code>{ "target": {}, "propertyKey": "decoratedProp" }</code> in the
console. It will compile to the following JS:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> __decorate <span class="op">=</span> (<span class="kw">this</span> <span class="op">&amp;&amp;</span> <span class="kw">this</span><span class="op">.</span><span class="at">__decorate</span>) <span class="op">||</span> <span class="kw">function</span> (decorators<span class="op">,</span> target<span class="op">,</span> key<span class="op">,</span> desc) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> c <span class="op">=</span> <span class="kw">arguments</span><span class="op">.</span><span class="at">length</span><span class="op">,</span> r <span class="op">=</span> c <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">?</span> target <span class="op">:</span> desc <span class="op">===</span> <span class="kw">null</span> <span class="op">?</span> desc <span class="op">=</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">getOwnPropertyDescriptor</span>(target<span class="op">,</span> key) <span class="op">:</span> desc<span class="op">,</span> d<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="kw">typeof</span> <span class="bu">Reflect</span> <span class="op">===</span> <span class="st">&quot;object&quot;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> <span class="bu">Reflect</span><span class="op">.</span><span class="at">decorate</span> <span class="op">===</span> <span class="st">&quot;function&quot;</span>) r <span class="op">=</span> <span class="bu">Reflect</span><span class="op">.</span><span class="fu">decorate</span>(decorators<span class="op">,</span> target<span class="op">,</span> key<span class="op">,</span> desc)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> decorators<span class="op">.</span><span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--</span>) <span class="cf">if</span> (d <span class="op">=</span> decorators[i]) r <span class="op">=</span> (c <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">?</span> <span class="fu">d</span>(r) <span class="op">:</span> c <span class="op">&gt;</span> <span class="dv">3</span> <span class="op">?</span> <span class="fu">d</span>(target<span class="op">,</span> key<span class="op">,</span> r) <span class="op">:</span> <span class="fu">d</span>(target<span class="op">,</span> key)) <span class="op">||</span> r<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c <span class="op">&gt;</span> <span class="dv">3</span> <span class="op">&amp;&amp;</span> r <span class="op">&amp;&amp;</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">defineProperty</span>(target<span class="op">,</span> key<span class="op">,</span> r)<span class="op">,</span> r<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> __metadata <span class="op">=</span> (<span class="kw">this</span> <span class="op">&amp;&amp;</span> <span class="kw">this</span><span class="op">.</span><span class="at">__metadata</span>) <span class="op">||</span> <span class="kw">function</span> (k<span class="op">,</span> v) {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="kw">typeof</span> <span class="bu">Reflect</span> <span class="op">===</span> <span class="st">&quot;object&quot;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> <span class="bu">Reflect</span><span class="op">.</span><span class="at">metadata</span> <span class="op">===</span> <span class="st">&quot;function&quot;</span>) <span class="cf">return</span> <span class="bu">Reflect</span><span class="op">.</span><span class="fu">metadata</span>(k<span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> MyDecorator <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (target<span class="op">,</span> propertyKey) <span class="kw">=&gt;</span> {</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>({ target<span class="op">,</span> propertyKey })<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="kw">class</span> MyComponent {</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    decoratedProp <span class="op">=</span> <span class="st">&quot;foobar&quot;</span><span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="fu">__decorate</span>([</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MyDecorator</span>()<span class="op">,</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">__metadata</span>(<span class="st">&quot;design:type&quot;</span><span class="op">,</span> <span class="bu">String</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>]<span class="op">,</span> MyComponent<span class="op">.</span><span class="at">prototype</span><span class="op">,</span> <span class="st">&quot;decoratedProp&quot;</span><span class="op">,</span> <span class="kw">void</span> <span class="dv">0</span>)<span class="op">;</span></span></code></pre></div>
<p>As you can see TypeScript basically includes a polyfill / helper
(<code>__decorate</code>) which implements the TypeScript vision for how
decorators should behave.</p>
<h3 id="differences-with-es-decorators">Differences with ES
Decorators</h3>
<p>So that all seems straightforward enough, and looks quite a bit like
how ES Decorators are designed to work. However, there are some
differences, mainly in the specific values that decorator functions will
be called with. For instance, <a
href="https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators">TS
Decorators which decorate a class property</a> (like our
<code>MyDecorator</code> example above) receive two arguments, the first
being the constructor of the class for a static member or the prototype
of the class for an instance member and the second being the name of the
member.</p>
<p>ES Decorators, by contrast, <a
href="https://github.com/tc39/proposal-decorators/#2-calling-decorators">receive
two arguments</a>, <code>value</code> and <code>context</code>, with
both differing based on what exactly is being decorated. In <a
href="https://github.com/tc39/proposal-decorators/#class-fields">the
case of class fields</a> <code>value</code> will be
<code>undefined</code>, and the name of the field can be found on the
<code>context</code> object.</p>
<p><a
href="https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories">Decorator
factories</a>, a pattern that TS Decorators have supported for a while,
is something that works fine with ES Decorators as well. This might look
something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  @<span class="fu">log</span>(<span class="st">&#39;info&#39;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  myField <span class="op">=</span> <span class="st">&quot;hey!&quot;</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>log</code> decorator factory takes an argument (a log
level, in this case) and then returns a decorator. This pattern can work
with both TS Decorators and ES Decorators, which matters for us since
the way that Stencil Decorators are used is basically as if they are
decorator factories, meaning we call the <code>Prop</code> decorator
like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Component {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  @<span class="fu">Prop</span>( <span class="co">/* optional params here */</span> )</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  foo<span class="op">:</span> <span class="dt">string</span> <span class="op">=</span> <span class="st">&quot;hey&quot;</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>So itâ€™s a good thing that no matter what we end up deciding to
support in Stencil going forward this pattern is the normal way to pass
options into a decorator.</p>
<h2 id="es-decorators-in-typescript-5.0">ES Decorators in TypeScript
5.0</h2>
<p>As of TypeScript 5.0, which is currently in beta, TypeScript supports
ES Decorators as specified by the TC39 proposal <em>as well as</em> the
now-legacy TS Decorators which it has supported for a while. TS
Decorators (the previous decorator implementation in TypeScript) are now
feature-flagged behind the <code>experimentalDecorators</code> option,
while the new implementation of ES Decorators is â€˜onâ€™ by default.
Obviously since these two types of decorators each â€˜claimâ€™ a chunk of
syntax (<code>@decoratorName</code>) they cannot both be used at
once.</p>
<p>Hereâ€™s an example of two simple decorators (one a decorator factory
actually) which will work in TypeScript <code>&gt;=5.0.0</code> (<a
href="https://www.staging-typescript.org/play?experimentalDecorators=false&amp;emitDecoratorMetadata=false&amp;module=7&amp;ts=5.0.0-dev.20230130#code/GYVwdgxgLglg9mABABQE5wA4B42YGoCGANgHyIAUmsCAzgFyIFgCeAlIgN4BQiiqAplBCokoSNTBYAKiXIB9KAVQBzQQ3AATfsBhh+GgDSIICKPwAeUBgGEiBGjQBiMfkQ0ARfidQEocVNamFlDSRrgYhKTs3Ly8JmA0cET8AHREcMrkAAYAyoKwYMqIIBgo6KXA-ogAJBw5UKi6mfFmlilgBAC2-KwAvogA7jBQABaIVPAJNRwAUjkA8gByKTQNTTDAzJQYEjR9Waw8iL0A3FynXFxi0JOI6crSsgpKqlbFYFo6eobGQZY2dgczlcHi8-l8-kCYFaISkRlWjUKJGiRz4gmEonANwQ5FGMHoiDhiAAbsQQPwGAimijYnFaElUvdsgBtAAy8wA4gBdOh0Wqkojk3oHM60tFCEQksn8VG9c6XCCAmiIACyzECnQwCH40M4RwAAuFyBxEJ1mPMdpMGA1ycdDrx9fcjlpvL59OFKWtCogALyIABElTgACMlP6znKuPFVr9NdrdX69ANVeq4HG9NDyKwTkA">TS
playground</a>) without <code>experimentalDecorators</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this is a sketch of Stencil&#39;s `Prop()` decorator</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> Prop<span class="op">&lt;</span>PropVal<span class="op">&gt;</span> (options<span class="op">:</span> <span class="dt">any</span>) {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">function</span><span class="op">&lt;</span>T<span class="op">&gt;</span>(_target<span class="op">:</span> <span class="dt">undefined</span><span class="op">,</span> context<span class="op">:</span> ClassFieldDecoratorContext<span class="op">&lt;</span>T<span class="op">,</span> PropVal<span class="op">&gt;</span>) {</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`Setting up Prop for </span><span class="sc">${</span><span class="bu">String</span>(context<span class="op">.</span><span class="at">name</span>)<span class="sc">}</span><span class="vs"> with options </span><span class="sc">${</span><span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(options)<span class="sc">}</span><span class="vs">`</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">log</span><span class="op">&lt;</span>T<span class="op">&gt;</span>(_target<span class="op">:</span> <span class="dt">undefined</span><span class="op">,</span> context<span class="op">:</span> ClassFieldDecoratorContext<span class="op">&lt;</span>T<span class="op">,</span> <span class="dt">string</span><span class="op">&gt;</span>) {</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">function</span>(<span class="kw">this</span><span class="op">:</span> T<span class="op">,</span> value<span class="op">:</span> <span class="dt">string</span>) {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`[LOG]::</span><span class="sc">${</span>value<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyComponent {</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  @<span class="fu">Prop</span>({ myOption<span class="op">:</span> <span class="kw">true</span> })</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  @log</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  decoratedProp<span class="op">:</span> <span class="dt">string</span> <span class="op">=</span> <span class="st">&quot;foobar&quot;</span><span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> component <span class="op">=</span> <span class="kw">new</span> <span class="fu">MyComponent</span>()<span class="op">;</span></span></code></pre></div>
<p>This compiles to quite a bit more code than TS Decorators with
<code>experimentalDecorators</code> did, check out the TS playground
linked above to see. It is helpful to run that code in the playground as
well to get a sense of when the decorator is actually called.</p>
<div class="note">
<p>Although as of TypeScript 5.0.0 it will be possible to use decorators
with the syntax and semantics described in the TC39 proposal this does
not mean that TypeScript will necessarily include any decorators in the
JS that it emits. As of this writing, TypeScript will only include the
<code>@decoratorname</code> syntax in the output if the compilation
target is set to <code>ESNext</code> and the
<code>useDefineForClassFields</code> option is set to <code>true</code>.
You can see an example of what the output looks like here: <a
href="https://www.staging-typescript.org/play?useDefineForClassFields=true&amp;experimentalDecorators=false&amp;emitDecoratorMetadata=false&amp;target=99&amp;module=7&amp;ts=5.0.0-dev.20230130#code/GYVwdgxgLglg9mABABQE5wA4B42YGoCGANgHyIAUmsCAzgFyIFgCeAlIgN4BQiiqAplBCokoSNTBYAKiXIB9KAVQBzQQ3AATfsBhh+GgDSIICKPwAeUBgGEiBGjQBiMfkQ0ARfidQEocVNamFlDSRrgYhKTs3Ly8JmA0cET8AHREcMrkAAYAyoKwYMqIIBgo6KXA-ogAJBw5UKi6mfFmlilgBAC2-KwAvogA7jBQABaIVPAJNRwAUjkA8gByKTQNTTDAzJQYEjR9Waw8iL0A3FynXFxi0JOI6crSsgpKqlbFYFo6eobGQZY2dgczlcHi8-l8-kCYFaISkRlWjUKJGiRz4gmEonANwQ5FGMHoiDhiAAbsQQPwGAimijYnFaElUvdsgBtAAy8wA4gBdOh0Wqkojk3oHM60tFCEQksn8VG9c6XCCAmiIACyzECnQwCH40M4RwAAuFyBxEJ1mPMdpMGA1ycdDrx9fcjlpvL59OFKWtCogALyIABElTgACMlP6znKuPFVr9NdrdX69ANVeq4HG9NDyKwTkA">TS
Playground</a>. This is all quite sensible, as browsers <a
href="https://caniuse.com/?search=decorators">do not yet support
decorators</a>.</p>
</div>
<h1
id="how-are-stencils-built-in-decorators-prop-watch-etc-implemented">How
are Stencilâ€™s built-in decorators (<code>Prop</code>,
<code>Watch</code>, etc) implemented?</h1>
<p>Stencilâ€™s has built-in decorators like <code>@Prop</code>,
<code>@Watch</code>, and <code>@Component</code> which are core pillars
of the DSL that allows Stencil users to add props, reactive data, and
more to their components. Something which is not obvious if you are just
trying to use Stencil to author a component, however, is that the
behavior, side effects, options, etc which are specified by using these
decorators are not actually implemented using actual TS Decorators
<em>or</em> ES Decorators.</p>
<p>Instead, the Stencil compiler uses TypeScript transforms to recognize
and transform these special, built-in decorators at compile-time.
Metadata is added to the compiled Stencil component and the syntax tree
nodes corresponding to the built-in decorators are removed. The code for
this is in
<code>src/compiler/transformers/decorators-to-static/</code>.</p>
<p>This process looks something like this:</p>
<pre class="mermaid"><code>flowchart TB
    A[Component using State, Prop, etc] --&gt;|transformed to| B
    subgraph TypeScript
    B --&gt; |compiled to| C
    B[&quot;Component with metadata annotations\n(built-in decorators removed)&quot;]
    C[&quot;Compiled Output\n(with metadata)&quot;]
    end
    C --&gt;|read by| D[Stencil runtime]</code></pre>
<p>Essentially, although it <em>looks</em> like youâ€™re using a decorator
on a syntax level when you author a Stencil component, in reality,
behind the scenes, this gets transformed into properties on the compiled
component class which hold necessary metadata (like prop names, default
values, etc) and then code in the Stencil runtime takes that metadata
and actually puts values where they are supposed to go, sets up
watchers, and so on. This is a bit confusing, but it does mean that
<em>as far as Stencil Decorators are concerned</em>, there is no change
necessary to upgrade to TypeScript 5.0. The same, however, cannot be
said for support for user-defined decorators in Stencil.</p>
<h1 id="stencils-support-for-custom-decorators">Stencilâ€™s support for
custom decorators</h1>
<p>While we support a small set of Stencil Decorators which are
implemented through a combination of AoT transformation and runtime
code, we have not historically endorsed or recommended component authors
implementing their own custom functionality using decorators. However,
this did work in earlier versions of Stencil, but was inadvertently
broken in v2.19.0.</p>
<p>Overall, my impression is that custom decorators are used by a small
minority of Stencil users. However, supporting them fully in the future
is consistent with Stencilâ€™s approach of using widespread frontend
standards such as TypeScript, Sass, etc. Users expect that, since it
looks like a TypeScript file, they should have access to the full range
of expression of TypeScript while they work on their components.</p>
<h2 id="in-versions-2.18.1">In versions &lt;=2.18.1</h2>
<p>In Stencil version 2.18.1 and earlier custom decorators worked just
fine as long as users did not set the
<code>useDefineForClassFields</code> option in their TypeScript
configuration.</p>
<h2 id="in-versions-2.19.0">In versions 2.19.0+</h2>
<p>In 2.19.0 we released <a
href="https://github.com/ionic-team/stencil/commit/f97783029274f9ee5ea58ba74ab15905c5113c93">a
change</a> which fixed an issue with Stencil Decorators and the
<code>useDefineForClassFields</code> TypeScript option. Essentially, the
<code>useDefineForClassFields</code> option causes TypeScript to emit
class fields in JS, like so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  bar <span class="op">=</span> <span class="st">&quot;baz&quot;</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>whereas previously it would add statements to initialize the property
to the classâ€™ constructor, like so:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Foo {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>() {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">foo</span> <span class="op">=</span> <span class="st">&quot;baz&quot;</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The problem was that the Stencil runtime code for <code>State</code>
and <code>Prop</code> depends on being able to use
<code>Object.defineProperty</code> in order to set, in this case, the
<code>foo</code> property on the <code>prototype</code> for the class.
This works fine if the fieldâ€™s value is initialized in the constructor,
but it does <em>not</em> work if itâ€™s initialized as a field. So the
change we made detected when a field was decorated with
<code>State</code> or <code>Prop</code> and, if so, it deleted the field
from the body of the class and manually added statements to the classâ€™
constructor to properly initialize it. This allows Stencil Decorators to
work correctly with <code>useDefineForClassFields</code> set to either
<code>true</code> or <code>false</code>, but it had an unintended side
effect of <a
href="https://github.com/ionic-team/stencil/issues/3831">breaking
support for custom decorators</a>. Now we need to make some sort of
change in order to restore support for using custom decorators in
Stencil.</p>
<h1
id="recommendations-for-decorator-support-in-stencil">Recommendations
for decorator support in Stencil</h1>
<p>The inclusion of ES Decorators in TypeScript 5.0 means that, as we
look to upgrade, we need to evaluate the stance that Stencil should
take. There are essentially four possible scenarios that I see for how
we can handle the TypeScript 5.0 upgrade in relation to decorators:</p>
<h2 id="possible-scenarios">Possible scenarios</h2>
<p>These four different scenarios are the different ways that I see that
we could handle support for Stencil Decorators, the upgrade to
TypeScript 5.0, and support for custom decorators (whether TS Decorators
or ES Decorators).</p>
<h3 id="status-quo">Status quo</h3>
<p>Custom decorators (TS Decorators <em>and</em> ES Decorators, although
the latter at this point only hypothetically) <a
href="https://github.com/ionic-team/stencil/issues/3831">are currently
broken / unsupported in Stencil</a>, while Stencil Decorators work fine.
A viable path to TS 5.0 (and, in fact, the shortest path) would be to
continue to punt on reconciling the changes made in 2.19.0 with
non-Stencil Decorators. Since we remove the concrete syntax tree nodes
corresponding to Stencil Decorators during compilation, the change in
handling the decorator syntax <code>@decoratorname</code> in the
TypeScript compiler wonâ€™t matter, and we could continue to support the
same developer experience we do currently.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>no need to make code changes in Stencil beyond the minimum necessary
to upgrade TypeScript</li>
<li>no change in semantics or behavior of Stencil Decorators</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>no support for custom decorators</li>
<li>continued maintenance burden of complex transformer code</li>
<li>components continue to be written not in TypeScript <em>per se</em>
but in our loosely specified DSL<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
</ul>
<h3
id="custom-ts-decorators-or-es-decorators-alongside-stencil-decorators">Custom
TS Decorators <em>or</em> ES Decorators alongside Stencil
decorators</h3>
<p>A possible scenario would be to maintain Stencil Decorators as they
are but additionally implement support for custom decorators through
further custom transformers which would recognize the usage of a custom
(i.e.Â non-Stencil) decorator and make appropriate changes in order to
call it with the correct arguments.</p>
<p>As discussed above, due to the changes implemented in 2.19.0 to
support the <code>useDefineForClassFields</code> option we need to do
additional transformation work in order to restore support for custom
decorators. I recently put together a <a
href="https://github.com/alicewriteswrongs/ts-static-decorators-transform">proof-of-concept
of this approach for TS Decorators</a> which explains some of how this
works and why it is necessary. Unfortunately, any approach to doing this
is likely to be at least somewhat brittle and will, I believe, have to
depend on non-public TS apis (as the PoC does).</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li><em>possibly</em> offers the quickest path to restoring custom
decorator support</li>
<li>no change in semantics or behavior of Stencil Decorators</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>increase in code complexity (new transformers)</li>
<li>significant effort involved in supporting a relatively minor
use-case</li>
<li>stencil components involving TS Decorators or ES Decorators
<em>and</em> Stencil Decorators is a definite increase in how â€˜eclecticâ€™
the Stencil compilerâ€™s dialect of TypeScript is (or, put another way,
weâ€™ll most likely create and / or run into a lot of subtle bugs)</li>
</ul>
<h3
id="support-custom-ts-decorators-and-custom-es-decorators-maintain-stencil-decorators">Support
custom TS Decorators <em>and</em> custom ES Decorators, maintain Stencil
decorators</h3>
<p>Similar to the scenario above, we could keep Stencil Decorators as
they are (implemented with TS transformers and custom runtime code) and
add further transformers which detect whether the
<code>experimentalDecorators</code> option is set to <code>true</code>,
and, if so, transformers for custom TS Decorators would be used, or if
<code>false</code>, transformers for custom ES Decorators would be used.
This is obviously the most complex option possible, but it would allow
us to support custom decorators, according to the userâ€™s preference (TS
Decorators or ES Decorators), while avoiding a rewrite of the Stencil
Decorators.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>no change in semantics or behavior of Stencil Decorators</li>
<li>support for custom decorators of any flavor</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>dramatic increase in code complexity (new transformers)</li>
<li>significant effort involved in support a relatively minor
use-case</li>
<li>supporting three different kinds of decorators, and maintaining
transformer code for all three, is stressful even just to think
about</li>
</ul>
<h3 id="all-in-on-es-decorators">All in on ES Decorators</h3>
<p>As part of the TypeScript 5.0 upgrade, or shortly thereafter, we port
all the Stencil Decorators to ES Decorators. By doing so, we could
remove all the code related to transforming Stencil Decorators, and the
functionality currently provided by the hybrid approach of some AoT
transformation work and some runtime work would be provided by an ES
Decorator directly. In a sense, this would be converting Stencilâ€™s
built-in decorators from something implemented by the Stencil compiler
into something Stencil users import from a library. Removing the
<code>decorators-to-static</code> transformers would also clear the way
for Stencil users to create their own decorators, since our custom
decorator implementation would no longer be messing around with the
TypeScript syntax tree and stepping on their toes.</p>
<p>One caveat with this approach is that because ES Decorators and TS
Decorators cannot be mixed<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> we could have to enforce
that Stencil users do not have <code>experimentalDecorators</code> set
in their <code>tsconfig.json</code>.</p>
<p><strong>Advantages</strong></p>
<ul>
<li>decorators used for Stencil components are no longer â€˜specialâ€™</li>
<li>custom decorator support is gained â€˜for freeâ€™ (we do not need to do
extra work to support it)</li>
<li>a good deal of code can be deleted</li>
<li>fairly â€˜future proofâ€™</li>
<li>would result in an overall simplification of the codebase</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>porting all the Stencil decorators to ES Decorators is a significant
amount of work</li>
</ul>
<h2 id="my-recommendation">My recommendation</h2>
<p>I believe that the best option is to go â€˜all inâ€™ on ES Decorators.
That way we support one single decorator standard, and that standard
happens to be the most modern and best standardized one <em>and</em> the
one which will eventually run in browsers. This approach reduces the
distance between Stencilâ€™s implicitly-defined dialect of TypeScript and
TypeScript itself, and would allow us to remove a good deal of complex,
difficult-to-debug code from the codebase. We would restore custom
decorator support not by implementing complex code transforms to
jerry-rig it in, but simply by doing things â€˜the right way.â€™</p>
<p>This approach is not without risks. The runtime code for
<code>Prop</code>, <code>State</code>, <code>Watch</code>, etc is
complex and not well understood (I believe) by the team at present, and
much of it is undocumented.</p>
<p>These risks could be mitigated by first upgrading to TypeScript 5.0
and then converting Stencil Decorators to ES Decorators one at a time.
The lessons learned from the first one to be completed would likely
clarify the viability of the path overall.</p>
<p>Additionally, a feature flag could be used to gate the new ES
Decorator-based <code>State</code>, <code>Prop</code> and so on while
the current, working functionality was left in place. We could then
deprecate the â€˜legacyâ€™ Stencil decorators at some point in the future
when the ES Decorator variants are fully stabilized.</p>
<p>A gradual approach would allow for custom decorators as soon as
<code>State</code> and <code>Prop</code> have been converted to ES
Decorators, since the problem with custom decorators only exists on
those fields.</p>
<p>The current implementation of decorators in Stencil is functional but
showing its age. TypeScript 5.0 offers us an opportunity to reimagine
how we implement Stencilâ€™s component DSL in a â€˜ES-nativeâ€™ way, getting
rid of custom, one-off solutions in favor of leveraging standardized
language features and tools.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>See the <a
href="https://github.com/ionic-team/stencil/issues/4011">Introduction to
the standard</a> for more on what this means<a href="#fnref1"
class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn2"><p>I believe that the fact that Stencilâ€™s AoT compilation
means that component authors are actually writing their components in a
different, albeit closely related, programming language is probably not
widely understood, and is an ongoing liability in terms of bugs and
issues when the behavior that we implement does not match the userâ€™s
expectations.<a href="#fnref2" class="footnote-back"
role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn3"><p>I believe this is the case, although I have not seen
anything specifically saying so. Given that TS Decorators and ES
Decorators have different type signatures and semantics I cannot see how
they could be used in the same project.<a href="#fnref3"
class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
</ol>
</section>
</body>
</html>
